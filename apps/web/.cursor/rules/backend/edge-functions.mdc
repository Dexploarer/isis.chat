---
category: backend
subcategory: edge-functions
tags: [vercel, edge-runtime, serverless, middleware, performance]
cursor:
  context_window: 8192
  temperature: 0.5
  max_tokens: 4096
  model_preference: ["claude-3.5-sonnet", "gpt-4-turbo"]
relations:
  imports: ["./api-design.mdc", "../security/authentication.mdc"]
  exports: ["edge-patterns", "middleware-patterns", "optimization-strategies"]
  references: ["./convex-patterns.mdc", "./caching.mdc"]
---

# Vercel Edge Functions - 2025 Runtime Patterns

## Core Edge Runtime Principles

**Global Distribution**: Functions run at 70+ edge locations worldwide for <50ms latency
**V8 Optimization**: Lightweight runtime with 9x faster cold starts than traditional serverless
**Resource Efficiency**: 4MB function limit, 1MB request limit, optimized for speed
**Web Standards**: Built on Web APIs for maximum compatibility and performance

## Authentication Middleware Patterns

### Solana Wallet Authentication
```typescript
// middleware.ts - Edge middleware for wallet auth
import { NextRequest, NextResponse } from 'next/server';
import { verifyMessage } from '@solana/web3.js';

export async function middleware(request: NextRequest) {
  // Skip auth for public routes
  if (request.nextUrl.pathname.startsWith('/api/public')) {
    return NextResponse.next();
  }
  
  // Extract authentication headers
  const signature = request.headers.get('x-wallet-signature');
  const message = request.headers.get('x-wallet-message');
  const publicKey = request.headers.get('x-wallet-pubkey');
  const timestamp = request.headers.get('x-timestamp');
  
  if (!signature || !message || !publicKey || !timestamp) {
    return new NextResponse(
      JSON.stringify({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Missing authentication headers',
        },
      }),
      { 
        status: 401,
        headers: { 'content-type': 'application/json' },
      }
    );
  }
  
  // Verify timestamp (prevent replay attacks)
  const now = Date.now();
  const requestTime = parseInt(timestamp);
  if (now - requestTime > 300000) { // 5 minutes
    return new NextResponse(
      JSON.stringify({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Request timestamp expired',
        },
      }),
      { status: 401, headers: { 'content-type': 'application/json' } }
    );
  }
  
  try {
    // Verify Solana wallet signature
    const isValid = await verifyWalletSignature(message, signature, publicKey);
    
    if (!isValid) {
      return new NextResponse(
        JSON.stringify({
          success: false,
          error: {
            code: 'UNAUTHORIZED',
            message: 'Invalid wallet signature',
          },
        }),
        { status: 401, headers: { 'content-type': 'application/json' } }
      );
    }
    
    // Add validated wallet address to request headers
    const response = NextResponse.next();
    response.headers.set('x-verified-wallet', publicKey);
    response.headers.set('x-auth-timestamp', timestamp);
    
    return response;
    
  } catch (error) {
    console.error('Auth verification failed:', error);
    return new NextResponse(
      JSON.stringify({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Authentication verification failed',
        },
      }),
      { status: 500, headers: { 'content-type': 'application/json' } }
    );
  }
}

// Configure middleware to run on API routes
export const config = {
  matcher: ['/api/:path*'],
};

// Helper function for signature verification
async function verifyWalletSignature(
  message: string, 
  signature: string, 
  publicKey: string
): Promise<boolean> {
  try {
    // Import Web3.js verification utilities
    const { PublicKey, ed25519 } = await import('@solana/web3.js');
    
    const pubKey = new PublicKey(publicKey);
    const messageBytes = new TextEncoder().encode(message);
    const signatureBytes = Buffer.from(signature, 'base64');
    
    return ed25519.verify(signatureBytes, messageBytes, pubKey.toBytes());
  } catch {
    return false;
  }
}
```

### Rate Limiting Edge Middleware
```typescript
// middleware/rate-limit.ts
import { NextRequest, NextResponse } from 'next/server';

interface RateLimitConfig {
  requests: number;
  window: number; // seconds
}

const RATE_LIMITS: Record<string, RateLimitConfig> = {
  '/api/chat/send': { requests: 20, window: 60 },
  '/api/documents/upload': { requests: 5, window: 300 },
  '/api/search': { requests: 100, window: 60 },
  default: { requests: 60, window: 60 },
};

// Edge-compatible rate limiting with Redis alternative
class EdgeRateLimit {
  private cache = new Map<string, { count: number; window: number }>();
  
  async check(key: string, config: RateLimitConfig): Promise<{
    allowed: boolean;
    remaining: number;
    resetTime: number;
  }> {
    const now = Date.now();
    const windowStart = Math.floor(now / (config.window * 1000)) * config.window * 1000;
    const cacheKey = `${key}:${windowStart}`;
    
    const existing = this.cache.get(cacheKey);
    
    if (!existing) {
      this.cache.set(cacheKey, { count: 1, window: windowStart });
      // Clean old entries
      this.cleanup(now);
      
      return {
        allowed: true,
        remaining: config.requests - 1,
        resetTime: windowStart + (config.window * 1000),
      };
    }
    
    if (existing.count >= config.requests) {
      return {
        allowed: false,
        remaining: 0,
        resetTime: windowStart + (config.window * 1000),
      };
    }
    
    existing.count++;
    
    return {
      allowed: true,
      remaining: config.requests - existing.count,
      resetTime: windowStart + (config.window * 1000),
    };
  }
  
  private cleanup(currentTime: number) {
    // Remove entries older than 1 hour
    const cutoff = currentTime - (3600 * 1000);
    
    for (const [key, value] of this.cache.entries()) {
      if (value.window < cutoff) {
        this.cache.delete(key);
      }
    }
  }
}

const rateLimiter = new EdgeRateLimit();

export async function rateLimit(request: NextRequest) {
  const walletAddress = request.headers.get('x-verified-wallet');
  const pathname = request.nextUrl.pathname;
  
  if (!walletAddress) {
    return NextResponse.next(); // Skip if no wallet (handled by auth middleware)
  }
  
  // Get rate limit config for this endpoint
  const config = RATE_LIMITS[pathname] || RATE_LIMITS.default;
  const key = `${walletAddress}:${pathname}`;
  
  const result = await rateLimiter.check(key, config);
  
  if (!result.allowed) {
    return new NextResponse(
      JSON.stringify({
        success: false,
        error: {
          code: 'RATE_LIMIT_EXCEEDED',
          message: 'Too many requests. Please try again later.',
          retryAfter: Math.ceil((result.resetTime - Date.now()) / 1000),
        },
      }),
      {
        status: 429,
        headers: {
          'Content-Type': 'application/json',
          'X-RateLimit-Limit': config.requests.toString(),
          'X-RateLimit-Remaining': result.remaining.toString(),
          'X-RateLimit-Reset': result.resetTime.toString(),
          'Retry-After': Math.ceil((result.resetTime - Date.now()) / 1000).toString(),
        },
      }
    );
  }
  
  // Add rate limit headers to response
  const response = NextResponse.next();
  response.headers.set('X-RateLimit-Limit', config.requests.toString());
  response.headers.set('X-RateLimit-Remaining', result.remaining.toString());
  response.headers.set('X-RateLimit-Reset', result.resetTime.toString());
  
  return response;
}
```

## API Route Patterns

### Optimized Chat API Route
```typescript
// app/api/chat/send/route.ts
import { NextRequest } from 'next/server';
import { ConvexHttpClient } from 'convex/browser';

// Initialize Convex client at module level for reuse
const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export const runtime = 'edge'; // Enable Edge Runtime

export async function POST(request: NextRequest) {
  try {
    // Get validated wallet from middleware
    const walletAddress = request.headers.get('x-verified-wallet');
    if (!walletAddress) {
      return Response.json({
        success: false,
        error: { code: 'UNAUTHORIZED', message: 'Wallet not authenticated' },
      }, { status: 401 });
    }
    
    // Parse request body with size limits
    const body = await request.json();
    
    // Validate input
    const validation = validateChatRequest(body);
    if (!validation.valid) {
      return Response.json({
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: validation.error,
          field: validation.field,
        },
      }, { status: 400 });
    }
    
    // Check user subscription and limits
    const canSend = await checkMessageLimits(walletAddress);
    if (!canSend.allowed) {
      return Response.json({
        success: false,
        error: {
          code: 'QUOTA_EXCEEDED',
          message: canSend.reason,
        },
      }, { status: 429 });
    }
    
    // Create message via Convex
    const messageId = await convex.mutation(api.messages.createMessage, {
      walletAddress,
      chatId: body.chatId,
      content: body.content,
      role: 'user',
    });
    
    // Schedule AI response generation (non-blocking)
    convex.action(api.ai.generateResponse, {
      messageId,
      walletAddress,
    }).catch(error => {
      console.error('AI response generation failed:', error);
    });
    
    return Response.json({
      success: true,
      data: { messageId },
      metadata: {
        requestId: request.headers.get('x-request-id') || crypto.randomUUID(),
        timestamp: Date.now(),
        processingTime: Date.now() - parseInt(request.headers.get('x-timestamp') || '0'),
        version: '1.0',
      },
    });
    
  } catch (error) {
    console.error('Chat API error:', error);
    
    return Response.json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Failed to send message. Please try again.',
      },
      metadata: {
        requestId: crypto.randomUUID(),
        timestamp: Date.now(),
        version: '1.0',
      },
    }, { status: 500 });
  }
}

// Edge-compatible validation helper
function validateChatRequest(body: any): { valid: boolean; error?: string; field?: string } {
  if (!body.chatId) {
    return { valid: false, error: 'Chat ID is required', field: 'chatId' };
  }
  
  if (!body.content || typeof body.content !== 'string') {
    return { valid: false, error: 'Message content is required', field: 'content' };
  }
  
  const trimmed = body.content.trim();
  if (trimmed.length === 0) {
    return { valid: false, error: 'Message cannot be empty', field: 'content' };
  }
  
  if (trimmed.length > 10000) {
    return { valid: false, error: 'Message must be less than 10,000 characters', field: 'content' };
  }
  
  return { valid: true };
}

// Check user message limits
async function checkMessageLimits(walletAddress: string) {
  try {
    const usage = await convex.query(api.usage.getDailyUsage, {
      walletAddress,
      date: new Date().toISOString().split('T')[0],
    });
    
    if (usage.messagesCount >= usage.messageLimit) {
      return {
        allowed: false,
        reason: 'Daily message limit reached. Upgrade your plan for more messages.',
      };
    }
    
    if (usage.tokensUsed >= usage.tokenLimit) {
      return {
        allowed: false,
        reason: 'Daily token limit reached. Upgrade your plan for more tokens.',
      };
    }
    
    return { allowed: true };
    
  } catch (error) {
    console.error('Usage check failed:', error);
    // Fail open - allow the request but log the error
    return { allowed: true };
  }
}
```

### Document Upload Edge Function
```typescript
// app/api/documents/upload/route.ts
import { NextRequest } from 'next/server';

export const runtime = 'edge';
export const maxDuration = 30; // 30 second timeout for document processing

export async function POST(request: NextRequest) {
  try {
    const walletAddress = request.headers.get('x-verified-wallet');
    if (!walletAddress) {
      return Response.json({
        success: false,
        error: { code: 'UNAUTHORIZED', message: 'Wallet not authenticated' },
      }, { status: 401 });
    }
    
    // Handle multipart form data in Edge Runtime
    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return Response.json({
        success: false,
        error: { code: 'VALIDATION_ERROR', message: 'File is required', field: 'file' },
      }, { status: 400 });
    }
    
    // Validate file size and type
    if (file.size > 10 * 1024 * 1024) { // 10MB limit
      return Response.json({
        success: false,
        error: { code: 'VALIDATION_ERROR', message: 'File size must be less than 10MB' },
      }, { status: 400 });
    }
    
    const allowedTypes = ['text/plain', 'application/pdf', 'text/markdown'];
    if (!allowedTypes.includes(file.type)) {
      return Response.json({
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Unsupported file type. Allowed: TXT, PDF, Markdown',
        },
      }, { status: 400 });
    }
    
    // Check user document limits
    const canUpload = await checkDocumentLimits(walletAddress);
    if (!canUpload.allowed) {
      return Response.json({
        success: false,
        error: { code: 'QUOTA_EXCEEDED', message: canUpload.reason },
      }, { status: 429 });
    }
    
    // Read file content
    const arrayBuffer = await file.arrayBuffer();
    const content = new TextDecoder().decode(arrayBuffer);
    
    // Create document hash for deduplication
    const hash = await generateContentHash(content);
    
    // Check for duplicate documents
    const existing = await convex.query(api.documents.getDocumentByHash, {
      walletAddress,
      hash,
    });
    
    if (existing) {
      return Response.json({
        success: true,
        data: {
          documentId: existing._id,
          duplicate: true,
          message: 'Document already exists',
        },
      });
    }
    
    // Create document in Convex
    const documentId = await convex.mutation(api.documents.createDocument, {
      walletAddress,
      title: file.name,
      content,
      type: file.type === 'application/pdf' ? 'pdf' : 
            file.type === 'text/markdown' ? 'markdown' : 'text',
      hash,
      size: file.size,
    });
    
    // Schedule document processing (chunking + embeddings)
    convex.action(api.documents.processDocument, {
      documentId,
      walletAddress,
    }).catch(error => {
      console.error('Document processing failed:', error);
    });
    
    return Response.json({
      success: true,
      data: {
        documentId,
        title: file.name,
        size: file.size,
        type: file.type,
        processing: true,
      },
      metadata: {
        requestId: crypto.randomUUID(),
        timestamp: Date.now(),
        version: '1.0',
      },
    });
    
  } catch (error) {
    console.error('Document upload error:', error);
    
    return Response.json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Document upload failed. Please try again.',
      },
    }, { status: 500 });
  }
}

// Generate SHA-256 hash of content for deduplication
async function generateContentHash(content: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(content);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

async function checkDocumentLimits(walletAddress: string) {
  try {
    const user = await convex.query(api.users.getUser, { walletAddress });
    
    if (!user) {
      return { allowed: false, reason: 'User not found' };
    }
    
    const documentCount = await convex.query(api.documents.getUserDocumentCount, {
      walletAddress,
    });
    
    const limits = {
      free: 10,
      pro: 100,
      enterprise: 1000,
    };
    
    const limit = limits[user.subscription.tier as keyof typeof limits] || limits.free;
    
    if (documentCount >= limit) {
      return {
        allowed: false,
        reason: `Document limit reached (${limit}). Upgrade your plan for more documents.`,
      };
    }
    
    return { allowed: true };
    
  } catch (error) {
    console.error('Document limits check failed:', error);
    return { allowed: true }; // Fail open
  }
}
```

## Real-time WebSocket Patterns

### Edge-Compatible WebSocket Proxy
```typescript
// app/api/realtime/route.ts
import { NextRequest } from 'next/server';

export const runtime = 'edge';

export async function GET(request: NextRequest) {
  try {
    const walletAddress = request.headers.get('x-verified-wallet');
    if (!walletAddress) {
      return new Response('Unauthorized', { status: 401 });
    }
    
    // Get WebSocket upgrade headers
    const upgrade = request.headers.get('upgrade');
    if (upgrade !== 'websocket') {
      return new Response('Expected WebSocket upgrade', { status: 400 });
    }
    
    // Proxy to Convex real-time endpoint with authentication
    const convexWsUrl = new URL('/api/stream', process.env.NEXT_PUBLIC_CONVEX_URL!);
    convexWsUrl.protocol = 'wss:';
    convexWsUrl.searchParams.set('wallet', walletAddress);
    convexWsUrl.searchParams.set('timestamp', Date.now().toString());
    
    // Create authenticated WebSocket connection
    const response = await fetch(convexWsUrl.toString(), {
      headers: {
        'Upgrade': 'websocket',
        'Connection': 'Upgrade',
        'Sec-WebSocket-Key': request.headers.get('sec-websocket-key') || '',
        'Sec-WebSocket-Version': '13',
        'X-Verified-Wallet': walletAddress,
      },
    });
    
    return response;
    
  } catch (error) {
    console.error('WebSocket connection failed:', error);
    return new Response('WebSocket connection failed', { status: 500 });
  }
}
```

## Caching & Performance Patterns

### Edge Caching with KV Store
```typescript
// lib/edge-cache.ts
interface CacheEntry<T> {
  data: T;
  expiry: number;
  version: string;
}

export class EdgeCache {
  private cache = new Map<string, CacheEntry<any>>();
  
  async get<T>(key: string): Promise<T | null> {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return null;
    }
    
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.data as T;
  }
  
  async set<T>(
    key: string, 
    data: T, 
    ttlSeconds: number = 300,
    version: string = '1.0'
  ): Promise<void> {
    const expiry = Date.now() + (ttlSeconds * 1000);
    
    this.cache.set(key, {
      data,
      expiry,
      version,
    });
    
    // Cleanup expired entries periodically
    if (this.cache.size > 1000) {
      this.cleanup();
    }
  }
  
  async invalidate(pattern: string): Promise<void> {
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
      }
    }
  }
  
  private cleanup(): void {
    const now = Date.now();
    
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiry) {
        this.cache.delete(key);
      }
    }
  }
}

// Global cache instance
export const edgeCache = new EdgeCache();
```

### Cached API Pattern
```typescript
// app/api/user/profile/route.ts
import { edgeCache } from '@/lib/edge-cache';

export const runtime = 'edge';

export async function GET(request: NextRequest) {
  try {
    const walletAddress = request.headers.get('x-verified-wallet');
    if (!walletAddress) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    // Try cache first
    const cacheKey = `user:profile:${walletAddress}`;
    const cached = await edgeCache.get(cacheKey);
    
    if (cached) {
      return Response.json({
        success: true,
        data: cached,
        metadata: {
          cached: true,
          timestamp: Date.now(),
        },
      });
    }
    
    // Fetch from Convex
    const user = await convex.query(api.users.getUser, { walletAddress });
    
    if (!user) {
      return Response.json({ error: 'User not found' }, { status: 404 });
    }
    
    // Cache for 5 minutes
    await edgeCache.set(cacheKey, user, 300);
    
    return Response.json({
      success: true,
      data: user,
      metadata: {
        cached: false,
        timestamp: Date.now(),
      },
    });
    
  } catch (error) {
    console.error('Profile fetch error:', error);
    return Response.json({ error: 'Internal error' }, { status: 500 });
  }
}
```

## Error Handling & Monitoring

### Comprehensive Error Handler
```typescript
// lib/edge-error-handler.ts
export interface EdgeError {
  code: string;
  message: string;
  statusCode: number;
  metadata?: Record<string, any>;
}

export class EdgeErrorHandler {
  static handle(error: any, requestId?: string): Response {
    const timestamp = Date.now();
    
    // Log error details
    console.error('Edge function error:', {
      error: error.message,
      stack: error.stack,
      requestId,
      timestamp,
    });
    
    // Determine error type and response
    let edgeError: EdgeError;
    
    if (error.name === 'ValidationError') {
      edgeError = {
        code: 'VALIDATION_ERROR',
        message: error.message,
        statusCode: 400,
        metadata: { field: error.field },
      };
    } else if (error.name === 'AuthError') {
      edgeError = {
        code: 'UNAUTHORIZED',
        message: 'Authentication failed',
        statusCode: 401,
      };
    } else if (error.name === 'RateLimitError') {
      edgeError = {
        code: 'RATE_LIMIT_EXCEEDED',
        message: error.message,
        statusCode: 429,
        metadata: { retryAfter: error.retryAfter },
      };
    } else {
      edgeError = {
        code: 'INTERNAL_ERROR',
        message: 'An unexpected error occurred',
        statusCode: 500,
      };
    }
    
    // Return structured error response
    return Response.json({
      success: false,
      error: edgeError,
      metadata: {
        requestId: requestId || crypto.randomUUID(),
        timestamp,
        version: '1.0',
      },
    }, { 
      status: edgeError.statusCode,
      headers: {
        'Content-Type': 'application/json',
        ...(edgeError.metadata?.retryAfter && {
          'Retry-After': edgeError.metadata.retryAfter.toString(),
        }),
      },
    });
  }
}
```

## Performance Optimization

### Bundle Size Optimization
```typescript
// next.config.ts - Edge function optimization
const nextConfig = {
  experimental: {
    runtime: 'edge',
  },
  
  // Optimize bundle size for edge functions
  webpack: (config: any, { isServer, dev }: any) => {
    if (isServer && !dev) {
      // Tree-shake unused modules
      config.optimization.usedExports = true;
      
      // Minimize bundle size
      config.optimization.sideEffects = false;
      
      // Enable compression
      config.plugins.push(
        new CompressionPlugin({
          algorithm: 'gzip',
          test: /\.(js|css|html|svg)$/,
          threshold: 8192,
          minRatio: 0.8,
        })
      );
    }
    
    return config;
  },
};
```

::alert{type="info"}
**Edge Runtime Benefits**:
- 9x faster cold starts than serverless functions
- Global distribution across 70+ locations
- <50ms latency worldwide
- 15x lower cost for compute-intensive operations
::

::alert{type="warning"}
**Edge Runtime Limitations**:
- No Node.js APIs (fs, path, process)
- 4MB function size limit
- 1MB request size limit  
- No TCP/UDP connections
- Limited to Web APIs only
::